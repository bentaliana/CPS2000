TEST OUTPUT: task4_codegen
Generated: 2025-05-31 17:12:34
================================================================================


================================================================================
TEST: Basic Program Structure
TESTING: Code generator produces correct structure for simple program
================================================================================

INPUT PROGRAM:

    let x:int = 42;
    __print x;
    

PROGRAM AST:
------------------------------------------------------------
Program
  VarDecl: x : int
    Literal: 42 (int)
  Print
    Identifier: x
------------------------------------------------------------

GENERATED PArIR:
------------------------------------------------------------
.main
push 4
jmp
halt
push 2
oframe
push 42
push 1
push 0
st
push [1:0]
print
cframe
halt
------------------------------------------------------------

TEST OUTCOME:
PASS

================================================================================


================================================================================
TEST: Arithmetic Operations
TESTING: Code generator correctly handles all arithmetic operations including modulo
================================================================================

INPUT PROGRAM:

    let a:int = 17;
    let b:int = 5;
    let sum:int = a + b;
    let diff:int = a - b;
    let prod:int = a * b;
    let quot:int = a / b;
    let rem:int = a % b;
    
    __print sum;
    __print diff;
    __print prod;
    __print quot;
    __print rem;
    

PROGRAM AST:
------------------------------------------------------------
Program
  VarDecl: a : int
    Literal: 17 (int)
  VarDecl: b : int
    Literal: 5 (int)
  VarDecl: sum : int
    BinaryOp: +
      Identifier: a
      Identifier: b
  VarDecl: diff : int
    BinaryOp: -
      Identifier: a
      Identifier: b
  VarDecl: prod : int
    BinaryOp: *
      Identifier: a
      Identifier: b
  VarDecl: quot : int
    BinaryOp: /
      Identifier: a
      Identifier: b
  VarDecl: rem : int
    BinaryOp: %
      Identifier: a
      Identifier: b
  Print
    Identifier: sum
  Print
    Identifier: diff
  Print
    Identifier: prod
  Print
    Identifier: quot
  Print
    Identifier: rem
------------------------------------------------------------

GENERATED PArIR:
------------------------------------------------------------
.main
push 4
jmp
halt
push 8
oframe
push 17
push 1
push 0
st
push 5
push 2
push 0
st
push [2:0]
push [1:0]
add
push 3
push 0
st
push [2:0]
push [1:0]
sub
push 4
push 0
st
push [2:0]
push [1:0]
mul
push 5
push 0
st
push [2:0]
push [1:0]
div
push 6
push 0
st
push [2:0]
push [1:0]
mod
push 7
push 0
st
push [3:0]
print
push [4:0]
print
push [5:0]
print
push [6:0]
print
push [7:0]
print
cframe
halt
------------------------------------------------------------

All arithmetic operations found:
  add: YES
  sub: YES
  mul: YES
  div: YES
  mod: YES

TEST OUTCOME:
PASS

================================================================================


================================================================================
TEST: Comparison Operations
TESTING: Code generator correctly handles all comparison operations
================================================================================

INPUT PROGRAM:

    let a:int = 10;
    let b:int = 5;
    
    let lt:bool = a < b;
    let gt:bool = a > b;
    let le:bool = a <= b;
    let ge:bool = a >= b;
    let eq:bool = a == b;
    let ne:bool = a != b;
    
    if (lt) { __print 1; }
    if (gt) { __print 2; }
    if (le) { __print 3; }
    if (ge) { __print 4; }
    if (eq) { __print 5; }
    if (ne) { __print 6; }
    

PROGRAM AST:
------------------------------------------------------------
Program
  VarDecl: a : int
    Literal: 10 (int)
  VarDecl: b : int
    Literal: 5 (int)
  VarDecl: lt : bool
    BinaryOp: <
      Identifier: a
      Identifier: b
  VarDecl: gt : bool
    BinaryOp: >
      Identifier: a
      Identifier: b
  VarDecl: le : bool
    BinaryOp: <=
      Identifier: a
      Identifier: b
  VarDecl: ge : bool
    BinaryOp: >=
      Identifier: a
      Identifier: b
  VarDecl: eq : bool
    BinaryOp: ==
      Identifier: a
      Identifier: b
  VarDecl: ne : bool
    BinaryOp: !=
      Identifier: a
      Identifier: b
  If
    Identifier: lt
    Block
      Print
        Literal: 1 (int)
  If
    Identifier: gt
    Block
      Print
        Literal: 2 (int)
  If
    Identifier: le
    Block
      Print
        Literal: 3 (int)
  If
    Identifier: ge
    Block
      Print
        Literal: 4 (int)
  If
... (9 more lines)
------------------------------------------------------------

GENERATED PArIR:
------------------------------------------------------------
.main
push 4
jmp
halt
push 9
oframe
push 10
push 1
push 0
st
push 5
push 2
push 0
st
push [2:0]
push [1:0]
lt
push 3
push 0
st
push [2:0]
push [1:0]
gt
push 4
push 0
st
push [2:0]
push [1:0]
le
push 5
push 0
st
push [2:0]
push [1:0]
ge
push 6
push 0
st
push [2:0]
push [1:0]
eq
push 7
push 0
st
push [2:0]
push [1:0]
eq
not
push 8
push 0
st
push [3:0]
push #PC+4
cjmp
push #PC+7
jmp
push 0
oframe
push 1
print
cframe
push [4:0]
push #PC+4
cjmp
push #PC+7
jmp
push 0
oframe
push 2
print
cframe
push [5:0]
push #PC+4
cjmp
push #PC+7
jmp
push 0
oframe
push 3
print
cframe
push [6:0]
push #PC+4
cjmp
push #PC+7
jmp
push 0
oframe
push 4
print
cframe
push [7:0]
push #PC+4
cjmp
push #PC+7
jmp
push 0
oframe
push 5
print
cframe
push [8:0]
push #PC+4
cjmp
push #PC+7
jmp
push 0
oframe
push 6
print
cframe
cframe
halt
------------------------------------------------------------

TEST OUTCOME:
PASS

================================================================================


================================================================================
TEST: Logical Operations
TESTING: Code generator correctly handles logical operations
================================================================================

INPUT PROGRAM:

    let a:bool = true;
    let b:bool = false;
    
    let and_result:bool = a and b;
    let or_result:bool = a or b;
    let not_result:bool = not a;
    
    if (and_result) { __print 1; }
    if (or_result) { __print 2; }
    if (not_result) { __print 3; }
    

PROGRAM AST:
------------------------------------------------------------
Program
  VarDecl: a : bool
    Literal: True (bool)
  VarDecl: b : bool
    Literal: False (bool)
  VarDecl: and_result : bool
    BinaryOp: and
      Identifier: a
      Identifier: b
  VarDecl: or_result : bool
    BinaryOp: or
      Identifier: a
      Identifier: b
  VarDecl: not_result : bool
    UnaryOp: not
      Identifier: a
  If
    Identifier: and_result
    Block
      Print
        Literal: 1 (int)
  If
    Identifier: or_result
    Block
      Print
        Literal: 2 (int)
  If
    Identifier: not_result
    Block
      Print
        Literal: 3 (int)
------------------------------------------------------------

GENERATED PArIR:
------------------------------------------------------------
.main
push 4
jmp
halt
push 6
oframe
push 1
push 1
push 0
st
push 0
push 2
push 0
st
push [2:0]
push [1:0]
and
push 3
push 0
st
push [2:0]
push [1:0]
or
push 4
push 0
st
push [1:0]
not
push 5
push 0
st
push [3:0]
push #PC+4
cjmp
push #PC+7
jmp
push 0
oframe
push 1
print
cframe
push [4:0]
push #PC+4
cjmp
push #PC+7
jmp
push 0
oframe
push 2
print
cframe
push [5:0]
push #PC+4
cjmp
push #PC+7
jmp
push 0
oframe
push 3
print
cframe
cframe
halt
------------------------------------------------------------

TEST OUTCOME:
PASS

================================================================================


================================================================================
TEST: Function Generation
TESTING: Code generator correctly handles functions
================================================================================

INPUT PROGRAM:

    fun add(x:int, y:int) -> int {
        return x + y;
    }
    
    fun multiply(a:int, b:int) -> int {
        let result:int = a * b;
        return result;
    }
    
    let sum:int = add(5, 10);
    let product:int = multiply(3, 4);
    __print sum;
    __print product;
    

PROGRAM AST:
------------------------------------------------------------
Program
  FuncDecl: add(x:int, y:int) -> int
    Param: x : int
    Param: y : int
    Block
      Return
        BinaryOp: +
          Identifier: x
          Identifier: y
  FuncDecl: multiply(a:int, b:int) -> int
    Param: a : int
    Param: b : int
    Block
      VarDecl: result : int
        BinaryOp: *
          Identifier: a
          Identifier: b
      Return
        Identifier: result
  VarDecl: sum : int
    FuncCall: add
      Literal: 5 (int)
      Literal: 10 (int)
  VarDecl: product : int
    FuncCall: multiply
      Literal: 3 (int)
      Literal: 4 (int)
  Print
    Identifier: sum
  Print
    Identifier: product
------------------------------------------------------------

GENERATED PArIR:
------------------------------------------------------------
.main
push 4
jmp
halt
push 3
oframe
push #PC+9
jmp
.add
push 2
alloc
push [1:0]
push [0:0]
add
ret
push #PC+13
jmp
.multiply
push 3
alloc
push [1:0]
push [0:0]
mul
push 2
push 0
st
push [2:0]
ret
push 10
push 5
push 2
push .add
call
push 1
push 0
st
push 4
push 3
push 2
push .multiply
call
push 2
push 0
st
push [1:0]
print
push [2:0]
print
cframe
halt
------------------------------------------------------------

TEST OUTCOME:
PASS

================================================================================


================================================================================
TEST: Control Flow Generation
TESTING: Code generator correctly handles if/else, while, and for
================================================================================

INPUT PROGRAM:

    let x:int = 10;
    
    // If-else
    if (x > 5) {
        __print 1;
    } else {
        __print 0;
    }
    
    // While loop
    while (x > 0) {
        __print x;
        x = x - 1;
    }
    
    // For loop
    for (let i:int = 0; i < 5; i = i + 1) {
        if (i % 2 == 0) {
            __print i;
        }
    }
    

PROGRAM AST:
------------------------------------------------------------
Program
  VarDecl: x : int
    Literal: 10 (int)
  If
    BinaryOp: >
      Identifier: x
      Literal: 5 (int)
    Block
      Print
        Literal: 1 (int)
    Block
      Print
        Literal: 0 (int)
  While
    BinaryOp: >
      Identifier: x
      Literal: 0 (int)
    Block
      Print
        Identifier: x
      Assignment
        Identifier: x
        BinaryOp: -
          Identifier: x
          Literal: 1 (int)
  For
    VarDecl: i : int
      Literal: 0 (int)
    BinaryOp: <
      Identifier: i
      Literal: 5 (int)
    Assignment
      Identifier: i
      BinaryOp: +
        Identifier: i
        Literal: 1 (int)
    Block
      If
        BinaryOp: ==
          BinaryOp: %
            Identifier: i
            Literal: 2 (int)
          Literal: 0 (int)
        Block
          Print
            Identifier: i
------------------------------------------------------------

GENERATED PArIR:
------------------------------------------------------------
.main
push 4
jmp
halt
push 2
oframe
push 10
push 1
push 0
st
push 5
push [1:0]
gt
push #PC+4
cjmp
push #PC+9
jmp
push 0
oframe
push 1
print
cframe
push #PC+7
jmp
push 0
oframe
push 0
print
cframe
push 0
push [1:0]
gt
push #PC+4
cjmp
push #PC+15
jmp
push 0
oframe
push [1:1]
print
push 1
push [1:1]
sub
push 1
push 1
st
cframe
push #PC-18
jmp
push 1
oframe
push 0
push 0
push 0
st
push 5
push [0:0]
lt
push #PC+4
cjmp
push #PC+27
jmp
push 0
oframe
push 0
push 2
push [0:1]
mod
eq
push #PC+4
cjmp
push #PC+7
jmp
push 0
oframe
push [0:2]
print
cframe
cframe
push 1
push [0:0]
add
push 0
push 0
st
push #PC-31
jmp
cframe
cframe
halt
------------------------------------------------------------

TEST OUTCOME:
PASS

================================================================================


================================================================================
TEST: Built-in Operations
TESTING: Code generator correctly handles all built-in functions
================================================================================

INPUT PROGRAM:

    // Screen dimensions
    let w:int = __width;
    let h:int = __height;
    
    // Random number
    let rand:int = __randi 100;
    
    // Print
    __print 42;
    __print w;
    __print h;
    
    // Delay
    __delay 500;
    
    // Graphics operations
    __write 10, 20, #ff0000;
    __write_box 0, 0, 50, 50, #00ff00;
    let pixel:colour = __read 25, 25;
    __clear #0000ff;
    

PROGRAM AST:
------------------------------------------------------------
Program
  VarDecl: w : int
    BuiltIn: __width
  VarDecl: h : int
    BuiltIn: __height
  VarDecl: rand : int
    BuiltIn: __randi
      Literal: 100 (int)
  Print
    Literal: 42 (int)
  Print
    Identifier: w
  Print
    Identifier: h
  Delay
    Literal: 500 (int)
  Write
    Literal: 10 (int)
    Literal: 20 (int)
    Literal: #ff0000 (colour)
  WriteBox
    Literal: 0 (int)
    Literal: 0 (int)
    Literal: 50 (int)
    Literal: 50 (int)
    Literal: #00ff00 (colour)
  VarDecl: pixel : colour
    BuiltIn: __read
      Literal: 25 (int)
      Literal: 25 (int)
  Clear
    Literal: #0000ff (colour)
------------------------------------------------------------

GENERATED PArIR:
------------------------------------------------------------
.main
push 4
jmp
halt
push 5
oframe
width
push 1
push 0
st
height
push 2
push 0
st
push 100
irnd
push 3
push 0
st
push 42
print
push [1:0]
print
push [2:0]
print
push 500
delay
push #ff0000
push 20
push 10
write
push #00ff00
push 50
push 50
push 0
push 0
writebox
push 25
push 25
read
push 4
push 0
st
push #0000ff
clear
cframe
halt
------------------------------------------------------------

All built-in operations found:
  width: YES
  height: YES
  irnd: YES
  print: YES
  delay: YES
  write: YES
  writebox: YES
  read: YES
  clear: YES

TEST OUTCOME:
PASS

================================================================================


================================================================================
TEST: Type Casting
TESTING: Code generator correctly handles type casts
================================================================================

INPUT PROGRAM:

    let i:int = 42;
    let f:float = 3.14;
    let b:bool = true;
    let c:colour = #ff0000;
    
    // Various casts
    let i_to_f:float = i as float;
    let f_to_i:int = f as int;
    let i_to_b:bool = i as bool;
    let b_to_i:int = b as int;
    let i_to_c:colour = (255 * 256 * 256) as colour;
    let c_to_i:int = c as int;
    
    __print i_to_f;
    __print f_to_i;
    __print b_to_i;
    __print c_to_i;
    

PROGRAM AST:
------------------------------------------------------------
Program
  VarDecl: i : int
    Literal: 42 (int)
  VarDecl: f : float
    Literal: 3.14 (float)
  VarDecl: b : bool
    Literal: True (bool)
  VarDecl: c : colour
    Literal: #ff0000 (colour)
  VarDecl: i_to_f : float
    Cast -> float
      Identifier: i
  VarDecl: f_to_i : int
    Cast -> int
      Identifier: f
  VarDecl: i_to_b : bool
    Cast -> bool
      Identifier: i
  VarDecl: b_to_i : int
    Cast -> int
      Identifier: b
  VarDecl: i_to_c : colour
    Cast -> colour
      BinaryOp: *
        BinaryOp: *
          Literal: 255 (int)
          Literal: 256 (int)
        Literal: 256 (int)
  VarDecl: c_to_i : int
    Cast -> int
      Identifier: c
  Print
    Identifier: i_to_f
  Print
    Identifier: f_to_i
  Print
    Identifier: b_to_i
  Print
    Identifier: c_to_i
------------------------------------------------------------

GENERATED PArIR:
------------------------------------------------------------
.main
push 4
jmp
halt
push 11
oframe
push 42
push 1
push 0
st
push 3.14
push 2
push 0
st
push 1
push 3
push 0
st
push #ff0000
push 4
push 0
st
push [1:0]
push 5
push 0
st
push [2:0]
push 6
push 0
st
push [1:0]
push 7
push 0
st
push [3:0]
push 8
push 0
st
push 256
push 256
push 255
mul
mul
push 9
push 0
st
push [4:0]
push 10
push 0
st
push [5:0]
print
push [6:0]
print
push [8:0]
print
push [10:0]
print
cframe
halt
------------------------------------------------------------

TEST OUTCOME:
PASS

================================================================================


================================================================================
TEST: Complex Expressions
TESTING: Code generator correctly handles complex nested expressions
================================================================================

INPUT PROGRAM:

    let a:int = 10;
    let b:int = 5;
    let c:int = 3;
    
    // Complex arithmetic with precedence
    let result1:int = a + b * c - a / b % c;
    let result2:int = (a + b) * (c - 1);
    let result3:int = -a + -b * -c;
    
    // Complex boolean expressions
    let x:bool = a > b and b > c or a == 10;
    let y:bool = not (a < b) and (b != c);
    
    // Mixed expressions with casts
    let z:float = (a + b * c) as float / 2.0;
    
    __print result1;
    __print result2;
    __print result3;
    

PROGRAM AST:
------------------------------------------------------------
Program
  VarDecl: a : int
    Literal: 10 (int)
  VarDecl: b : int
    Literal: 5 (int)
  VarDecl: c : int
    Literal: 3 (int)
  VarDecl: result1 : int
    BinaryOp: -
      BinaryOp: +
        Identifier: a
        BinaryOp: *
          Identifier: b
          Identifier: c
      BinaryOp: %
        BinaryOp: /
          Identifier: a
          Identifier: b
        Identifier: c
  VarDecl: result2 : int
    BinaryOp: *
      BinaryOp: +
        Identifier: a
        Identifier: b
      BinaryOp: -
        Identifier: c
        Literal: 1 (int)
  VarDecl: result3 : int
    BinaryOp: +
      UnaryOp: -
        Identifier: a
      BinaryOp: *
        UnaryOp: -
          Identifier: b
        UnaryOp: -
          Identifier: c
  VarDecl: x : bool
    BinaryOp: or
      BinaryOp: and
        BinaryOp: >
          Identifier: a
          Identifier: b
        BinaryOp: >
          Identifier: b
          Identifier: c
      BinaryOp: ==
        Identifier: a
        Literal: 10 (int)
  VarDecl: y : bool
    BinaryOp: and
... (22 more lines)
------------------------------------------------------------

GENERATED PArIR:
------------------------------------------------------------
.main
push 4
jmp
halt
push 10
oframe
push 10
push 1
push 0
st
push 5
push 2
push 0
st
push 3
push 3
push 0
st
push [3:0]
push [2:0]
push [1:0]
div
mod
push [3:0]
push [2:0]
mul
push [1:0]
add
sub
push 4
push 0
st
push 1
push [3:0]
sub
push [2:0]
push [1:0]
add
mul
push 5
push 0
st
push [3:0]
push 0
sub
push [2:0]
push 0
sub
mul
push [1:0]
push 0
sub
add
push 6
push 0
st
push 10
push [1:0]
eq
push [3:0]
push [2:0]
gt
push [2:0]
push [1:0]
gt
and
or
push 7
push 0
st
push [3:0]
push [2:0]
eq
not
push [2:0]
push [1:0]
lt
not
and
push 8
push 0
st
push 2.0
push [3:0]
push [2:0]
mul
push [1:0]
add
div
push 9
push 0
st
push [4:0]
print
push [5:0]
print
push [6:0]
print
cframe
halt
------------------------------------------------------------

Instruction counts:
  Push operations: 56
  Arithmetic operations: 16

TEST OUTCOME:
PASS

================================================================================


================================================================================
TEST: Recursive Functions
TESTING: Code generator correctly handles recursive function calls
================================================================================

INPUT PROGRAM:

    fun factorial(n:int) -> int {
        if (n <= 1) {
            return 1;
        }
        return n * factorial(n - 1);
    }
    
    fun fibonacci(n:int) -> int {
        if (n <= 1) {
            return n;
        }
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
    
    let fact5:int = factorial(5);
    let fib7:int = fibonacci(7);
    
    __print fact5;
    __print fib7;
    

PROGRAM AST:
------------------------------------------------------------
Program
  FuncDecl: factorial(n:int) -> int
    Param: n : int
    Block
      If
        BinaryOp: <=
          Identifier: n
          Literal: 1 (int)
        Block
          Return
            Literal: 1 (int)
      Return
        BinaryOp: *
          Identifier: n
          FuncCall: factorial
            BinaryOp: -
              Identifier: n
              Literal: 1 (int)
  FuncDecl: fibonacci(n:int) -> int
    Param: n : int
    Block
      If
        BinaryOp: <=
          Identifier: n
          Literal: 1 (int)
        Block
          Return
            Identifier: n
      Return
        BinaryOp: +
          FuncCall: fibonacci
            BinaryOp: -
              Identifier: n
              Literal: 1 (int)
          FuncCall: fibonacci
            BinaryOp: -
              Identifier: n
              Literal: 2 (int)
  VarDecl: fact5 : int
    FuncCall: factorial
      Literal: 5 (int)
  VarDecl: fib7 : int
    FuncCall: fibonacci
      Literal: 7 (int)
  Print
    Identifier: fact5
  Print
    Identifier: fib7
------------------------------------------------------------

GENERATED PArIR:
------------------------------------------------------------
.main
push 4
jmp
halt
push 3
oframe
push #PC+26
jmp
.factorial
push 1
alloc
push 1
push [0:0]
le
push #PC+4
cjmp
push #PC+7
jmp
push 0
oframe
push 1
ret
cframe
push 1
push [0:0]
sub
push 1
push .factorial
call
push [0:0]
mul
ret
push #PC+31
jmp
.fibonacci
push 1
alloc
push 1
push [0:0]
le
push #PC+4
cjmp
push #PC+7
jmp
push 0
oframe
push [0:1]
ret
cframe
push 2
push [0:0]
sub
push 1
push .fibonacci
call
push 1
push [0:0]
sub
push 1
push .fibonacci
call
add
ret
push 5
push 1
push .factorial
call
push 1
push 0
st
push 7
push 1
push .fibonacci
call
push 2
push 0
st
push [1:0]
print
push [2:0]
print
cframe
halt
------------------------------------------------------------

TEST OUTCOME:
PASS

================================================================================


================================================================================
TEST: Modulo in Loops
TESTING: Code generator correctly handles modulo in loop conditions and bodies
================================================================================

INPUT PROGRAM:

    // Print even numbers using modulo
    for (let i:int = 0; i < 20; i = i + 1) {
        if (i % 2 == 0) {
            __print i;
        }
    }
    
    // Print numbers divisible by 3 or 5
    let n:int = 1;
    while (n <= 15) {
        if (n % 3 == 0 or n % 5 == 0) {
            __print n;
        }
        n = n + 1;
    }
    

PROGRAM AST:
------------------------------------------------------------
Program
  For
    VarDecl: i : int
      Literal: 0 (int)
    BinaryOp: <
      Identifier: i
      Literal: 20 (int)
    Assignment
      Identifier: i
      BinaryOp: +
        Identifier: i
        Literal: 1 (int)
    Block
      If
        BinaryOp: ==
          BinaryOp: %
            Identifier: i
            Literal: 2 (int)
          Literal: 0 (int)
        Block
          Print
            Identifier: i
  VarDecl: n : int
    Literal: 1 (int)
  While
    BinaryOp: <=
      Identifier: n
      Literal: 15 (int)
    Block
      If
        BinaryOp: or
          BinaryOp: ==
            BinaryOp: %
              Identifier: n
              Literal: 3 (int)
            Literal: 0 (int)
          BinaryOp: ==
            BinaryOp: %
              Identifier: n
              Literal: 5 (int)
            Literal: 0 (int)
        Block
          Print
            Identifier: n
      Assignment
        Identifier: n
        BinaryOp: +
          Identifier: n
          Literal: 1 (int)
------------------------------------------------------------

GENERATED PArIR:
------------------------------------------------------------
.main
push 4
jmp
halt
push 2
oframe
push 1
oframe
push 0
push 0
push 0
st
push 20
push [0:0]
lt
push #PC+4
cjmp
push #PC+27
jmp
push 0
oframe
push 0
push 2
push [0:1]
mod
eq
push #PC+4
cjmp
push #PC+7
jmp
push 0
oframe
push [0:2]
print
cframe
cframe
push 1
push [0:0]
add
push 0
push 0
st
push #PC-31
jmp
cframe
push 1
push 1
push 0
st
push 15
push [1:0]
le
push #PC+4
cjmp
push #PC+33
jmp
push 0
oframe
push 0
push 5
push [1:1]
mod
eq
push 0
push 3
push [1:1]
mod
eq
or
push #PC+4
cjmp
push #PC+7
jmp
push 0
oframe
push [1:2]
print
cframe
push 1
push [1:1]
add
push 1
push 1
st
cframe
push #PC-36
jmp
cframe
halt
------------------------------------------------------------

Modulo operations found: 3

TEST OUTCOME:
PASS

================================================================================


================================================================================
TEST: Complete Program
TESTING: Code generator handles complete program with all language features
================================================================================

INPUT PROGRAM:

    // Global variable
    let screen_cleared:bool = false;
    
    fun draw_pixel(x:int, y:int, c:colour) -> bool {
        if ((x >= 0 and x < __width and y >= 0 and y < __height) or screen_cleared) {
            __write x, y, c;
            return true;
        }
        return false;
    }
    
    fun clear_screen() -> bool {
        if (not screen_cleared) {
            __clear #000000;
            screen_cleared = true;
        }
        return screen_cleared;
    }
    
    fun main() -> int {
        let cleared:bool = clear_screen();
        
        // Draw a pattern
        for (let i:int = 0; i < 10; i = i + 1) {
            let x:int = i * 10;
            let y:int = i * 10;
            let color:colour = (i * 25) as colour;
            let drawn:bool = draw_pixel(x, y, color);
        }
        
        // Test modulo
        let a:int = 17;
        let b:int = 5;
        let remainder:int = a % b;
        __print remainder;
        
        __delay 1000;
        return 0;
    }
    
    let result:int = main();
    

PROGRAM AST:
------------------------------------------------------------
Program
  VarDecl: screen_cleared : bool
    Literal: False (bool)
  FuncDecl: draw_pixel(x:int, y:int, c:colour) -> bool
    Param: x : int
    Param: y : int
    Param: c : colour
    Block
      If
        BinaryOp: or
          BinaryOp: and
            BinaryOp: and
              BinaryOp: and
                BinaryOp: >=
                  Identifier: x
                  Literal: 0 (int)
                BinaryOp: <
                  Identifier: x
                  BuiltIn: __width
              BinaryOp: >=
                Identifier: y
                Literal: 0 (int)
            BinaryOp: <
              Identifier: y
              BuiltIn: __height
          Identifier: screen_cleared
        Block
          Write
            Identifier: x
            Identifier: y
            Identifier: c
          Return
            Literal: True (bool)
      Return
        Literal: False (bool)
  FuncDecl: clear_screen() -> bool
    Block
      If
        UnaryOp: not
          Identifier: screen_cleared
        Block
          Clear
            Literal: #000000 (colour)
          Assignment
            Identifier: screen_cleared
            Literal: True (bool)
      Return
        Identifier: screen_cleared
  FuncDecl: main() -> int
    Block
      VarDecl: cleared : bool
        FuncCall: clear_screen
      For
        VarDecl: i : int
          Literal: 0 (int)
        BinaryOp: <
          Identifier: i
          Literal: 10 (int)
        Assignment
          Identifier: i
          BinaryOp: +
            Identifier: i
            Literal: 1 (int)
        Block
          VarDecl: x : int
            BinaryOp: *
              Identifier: i
              Literal: 10 (int)
          VarDecl: y : int
            BinaryOp: *
              Identifier: i
              Literal: 10 (int)
          VarDecl: color : colour
            Cast -> colour
              BinaryOp: *
                Identifier: i
                Literal: 25 (int)
          VarDecl: drawn : bool
            FuncCall: draw_pixel
              Identifier: x
              Identifier: y
              Identifier: color
      VarDecl: a : int
        Literal: 17 (int)
      VarDecl: b : int
        Literal: 5 (int)
      VarDecl: remainder : int
        BinaryOp: %
          Identifier: a
          Identifier: b
      Print
        Identifier: remainder
      Delay
        Literal: 1000 (int)
      Return
        Literal: 0 (int)
  VarDecl: result : int
    FuncCall: main
------------------------------------------------------------

GENERATED PArIR:
------------------------------------------------------------
.main
push 4
jmp
halt
push 3
oframe
push #PC+37
jmp
.draw_pixel
push 3
alloc
push 0
height
push [1:0]
lt
push 0
push [1:0]
ge
width
push [0:0]
lt
push 0
push [0:0]
ge
and
and
and
or
push #PC+4
cjmp
push #PC+11
jmp
push 0
oframe
push [2:1]
push [1:1]
push [0:1]
write
push 1
ret
cframe
push 0
ret
push #PC+18
jmp
.clear_screen
push 0
alloc
push 0
not
push #PC+4
cjmp
push #PC+7
jmp
push 0
oframe
push #000000
clear
cframe
push 0
ret
push #PC+83
jmp
.main
push 4
alloc
push 0
push .clear_screen
call
push 0
push 0
st
push 1
oframe
push 0
push 0
push 0
st
push 10
push [0:0]
lt
push #PC+4
cjmp
push #PC+40
jmp
push 4
oframe
push 10
push [0:1]
mul
push 0
push 0
st
push 10
push [0:1]
mul
push 1
push 0
st
push 25
push [0:1]
mul
push 2
push 0
st
push [2:0]
push [1:0]
push [0:0]
push 3
push .draw_pixel
call
push 3
push 0
st
cframe
push 1
push [0:0]
add
push 0
push 0
st
push #PC-44
jmp
cframe
push 17
push 1
push 0
st
push 5
push 2
push 0
st
push [2:0]
push [1:0]
mod
push 3
push 0
st
push [3:0]
print
push 1000
delay
push 0
ret
push 0
push 1
push 0
st
push 0
push .main
call
push 2
... (4 more instructions)
------------------------------------------------------------

Total instructions generated: 156

FUNCTIONS:
  .draw_pixel: YES
  .clear_screen: YES
  .main: YES

OPERATIONS:
  mod: YES
  and: YES
  or: YES
  not: YES

CONTROL:
  cjmp: YES
  jmp: YES
  call: YES
  ret: YES

BUILTINS:
  write: YES
  clear: YES
  width: YES
  height: YES
  print: YES
  delay: YES

TEST OUTCOME:
PASS

================================================================================


================================================================================
TASK 4 SUMMARY
================================================================================
Basic Program                  PASS
Arithmetic Operations          PASS
Comparison Operations          PASS
Logical Operations             PASS
Function Generation            PASS
Control Flow                   PASS
Built-in Operations            PASS
Type Casting                   PASS
Complex Expressions            PASS
Recursive Functions            PASS
Modulo in Loops                PASS
Complete Program               PASS
--------------------------------------------------------------------------------
Total: 12/12 tests passed
